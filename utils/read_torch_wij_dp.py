#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
	Author: L. Wang
	Created in: April 2022
	
	Extract Wij and Bi from .pt file generated by KFDP. 


"""
import os
import sys
import json
import numpy as np
import yaml

#get the current working directory
sys.path.append(os.getcwd())

#get the abs path of this file
codepath=os.path.abspath(sys.path[0])

sys.path.append(codepath+'/../src/pre_data')
sys.path.append(codepath+'/..')

import torch

def getOrderedAtom(atom_config_path = "atom.config"):
    """
        get atom index with the same order as atom.config
    """
    ff = open(atom_config_path,"r")
    mvt_tmp = ff.readlines()
    mvt = [] 
    for item in mvt_tmp:
        mvt.append(item.split())
    knot = False

    num_atom = int(mvt[0][0])
    print ("atom number:" + str(num_atom))

    ordered_atomtype = [] 

    uom = {} 

    num_passed = 0 ; 

    for line in mvt:
        if knot:
            if line[0] not in uom:
                uom[line[0]] = True
                ordered_atomtype.append(line[0])
                
            num_passed +=1;        
            if num_passed == num_atom:
                break; 

        if "Position" in line[0]:
            knot = True

    return ordered_atomtype

def catNameEmbedingW(idxNet, idxLayer, has_module=""):
	return "{}embedding_net.".format(has_module)+str(idxNet)+".weights.weight"+str(idxLayer)

def catNameEmbedingB(idxNet, idxLayer, has_module=""):
	return "{}embedding_net.".format(has_module)+str(idxNet)+".bias.bias"+str(idxLayer)

def catNameFittingW(idxNet, idxLayer, has_module=""):
	return "{}fitting_net.".format(has_module)+str(idxNet)+".weights.weight"+str(idxLayer)

def catNameFittingB(idxNet, idxLayer, has_module=""):
	return "{}fitting_net.".format(has_module)+str(idxNet)+".bias.bias"+str(idxLayer)

def catNameFittingRes(idxNet, idxResNet, has_module=""):
	return "{}fitting_net.".format(has_module)+str(idxNet)+".resnet_dt.resnet_dt"+str(idxResNet)
    
def dump(item, f):
	raw_str = ''
	for num in item:
		raw_str += (str(float(num))+' ')
	f.write(raw_str)
	f.write('\n')
	#return raw_str

'''
Description: 
param {*} config_yaml
param {*} out_path
Returns: pm.iflag_PCA? 
Author: WU Xingxing
'''
def write_feat_info(out_path, config_yaml):
    feat_dir = os.path.join(out_path, "fread_dfeat")
    if os.path.exists(feat_dir) is False:
        os.makedirs(feat_dir)

    iflag_PCA = 0
    use_Ftype=[1]
    nfeat0m = 24
    nfeat_m_1 = 24
    ntypes = len(config_yaml["atomType"])
    maxNeighborNum=config_yaml["maxNeighborNum"]
    with open(os.path.join(feat_dir, "feat.info"), 'w') as f:
        f.writelines(str(iflag_PCA)+'\n')
        f.writelines(str(len(use_Ftype))+'\n')
        for m in range(len(use_Ftype)):
            f.writelines(str(use_Ftype[m])+'\n')

        f.writelines(str(ntypes)+', '+str(maxNeighborNum)+'\n')
        for i in range(ntypes):
            f.writelines(str(config_yaml["atomType"][i]['type'])+'  ' +
                         str(nfeat0m)+'  '+str(nfeat0m)+'\n')
        for i in range(ntypes):
            for m in range(len(use_Ftype)):
                f.writelines(str(nfeat_m_1)+'  ')
                # f.writelines(str(nfeat[m+1])+'  ')
            f.writelines('\n')

'''
Description: 
    create vdw_fitB.ntype file
    this function not be used 
param {*} out_path
param {*} config_yaml
Returns: 
Author: WU Xingxing
'''
def write_vdw(out_path, config_yaml):
    vdw_dir = os.path.join(out_path, "fread_dfeat")
    if os.path.exists(vdw_dir) is False:
        os.makedirs(vdw_dir)
    ntypes = len(config_yaml["atomType"])
    atomType = []
    strength_rad = 0.0
    for i in range(ntypes):
        atomType.append(config_yaml["atomType"][i]['type'])

    vdw_input = {
        'ntypes': len(config_yaml["atomType"]),
        'nterms': 1,
        'atom_type': atomType,
        'rad': [strength_rad for i in range(ntypes)],
        'e_ave': [0.0 for i in range(ntypes)],
        'wp': [ [0.0 for i in range(ntypes*1)] for i in range(ntypes)]
    }

    num_atom_type = vdw_input['ntypes']
    vdw_filename = os.path.join(vdw_dir,'vdw_fitB.ntype')
    with open(vdw_filename, 'w') as f_vdw:
        f_vdw.write('%d %d\n' % (vdw_input['ntypes'], vdw_input['nterms']))
        for i in range(num_atom_type):   # loop i for atomtypes
            f_vdw.write('%d %f %f ' % (vdw_input['atom_type'][i], vdw_input['rad'][i], vdw_input['e_ave'][i]))
            for j in range(len(vdw_input['wp'][i])):  # loop j for pm.ntypes*pm.nterms
                f_vdw.write(' %f ' % vdw_input['wp'][i][j])
            f_vdw.write('\n')

'''
Description: 
warning: feat_info function has same constant value

param {*} config_yaml train config yaml file
param {*} model_pt_path model file path
param {*} atom_config_path atom_config file path
param {*} out_path output dir 
param {*} davg_npy_path
param {*} dstd_npy_path
Returns: 
Author: WU Xingxing
'''
def read_torch_dp(config_yaml, model_pt_path, atom_config_path, out_path, davg_npy_path, dstd_npy_path):
    write_feat_info(out_path, config_yaml)
    write_vdw(out_path, config_yaml)
    atomType=config_yaml["atomType"][0]['type'] #control by config.json
    maxNeighborNum=config_yaml["maxNeighborNum"]
    netConfig = config_yaml["net_cfg"]

    isEmbedingNetResNet = netConfig["embedding_net"]["resnet_dt"]
    isFittingNetResNet  = netConfig["fitting_net"]["resnet_dt"]

    embedingNetSizes = netConfig['embedding_net']['network_size']
    nLayerEmbedingNet = len(embedingNetSizes)

    print("layer number of embeding net:"+str(nLayerEmbedingNet))
    print("size of each layer"+ str(embedingNetSizes) + '\n')

    fittingNetSizes = netConfig['fitting_net']['network_size']
    nLayerFittingNet = len(fittingNetSizes)

    print("layer number of fitting net:"+str(nLayerFittingNet))
    print("size of each layer"+ str(fittingNetSizes) + '\n')

    embedingNet_output = os.path.join(out_path, 'embeding.net')
    fittingNet_output = os.path.join(out_path, 'fitting.net')

    raw = torch.load(model_pt_path, map_location=torch.device("cpu"))['state_dict']
    has_module = "module." if "module" in list(raw.keys())[0] else ""
    module_sign = True if "module" in list(raw.keys())[0] else False

    tensor_list = list(raw.keys())

    #determining # of networks 
    nEmbedingNet = len(config_yaml["atomType"])**2  
    nFittingNet = len(config_yaml["atomType"])
        
    """
        write embedding network
    """

    f = open(embedingNet_output, 'w')

    # total number of embeding network
    f.write(str(nEmbedingNet)+'\n') 

    #layer of embeding network
    f.write(str(nLayerEmbedingNet) + '\n')

    #size of each layer

    f.write("1 ")
    for i in embedingNetSizes:
        f.write(str(i)+' ')

    f.write('\n')

    #f.writelines([str(i) for i in embedingNetSizes])
        
    print("******** converting embeding network starts ********")
    for idxNet in range(nEmbedingNet):
        print ("converting embeding network No."+str(idxNet))
        for idxLayer in range(nLayerEmbedingNet):
            print ("converting layer "+str(idxLayer) )	

            #write wij
            label_W = catNameEmbedingW(idxNet,idxLayer,has_module)
            for item in raw[label_W]:
                dump(item,f)

            print("w matrix dim:" +str(len(raw[label_W])) +str('*') +str(len(raw[label_W][0])))

            #write bi
            label_B = catNameEmbedingB(idxNet,idxLayer,has_module)
            dump(raw[label_B][0],f)
            print ("b dim:" + str(len(raw[label_B][0])))

        print ('\n')
            #break
    f.close()

    print("******** converting embeding network ends  *********")

    """
        write fitting network
    """

    f = open(fittingNet_output, 'w')

    # total number of embeding network
    f.write(str(nFittingNet)+'\n') 

    #layer of embeding network
    f.write(str(nLayerFittingNet) + '\n')

    #size of each layer

    f.write(str(len(raw[catNameFittingW(0,0,has_module)]))+' ')

    for i in fittingNetSizes:
        f.write(str(i)+' ')

    f.write('\n')

    print("******** converting fitting network starts ********")
    for idxNet in range(nFittingNet):
        print ("converting fitting network No."+str(idxNet))
        for idxLayer in range(nLayerFittingNet):
            print ("converting layer "+str(idxLayer) )  

            #write wij
            label_W = catNameFittingW(idxNet,idxLayer,has_module)
            for item in raw[label_W]:
                dump(item,f)

            print("w matrix dim:" +str(len(raw[label_W])) +str('*') +str(len(raw[label_W][0])))

            #write bi
            label_B = catNameFittingB(idxNet,idxLayer,has_module)
            dump(raw[label_B][0],f)
            print ("b dim:" + str(len(raw[label_B][0])))

        print ('\n')
            #break
    f.close()

    print("******** converting fitting network ends  *********")

    """
        writing ResNets
    """
    print("******** converting resnet starts  *********")
    if isFittingNetResNet:
        numResNet = 0

        """


        for keys in list(raw.keys()):
            tmp = keys.split('.')
            if tmp[0] == "fitting_net" and tmp[1] == '0' and tmp[2] == 'resnet_dt':
                numResNet +=1 

        print ("number of resnet: " + str(numResNet))

        filename  = "fittingNet.resnet"

        f= open(filename, "w")
        
        f.write(str(numResNet)+"\n")

        for fittingNetIdx in range(nFittingNet):
            for resNetIdx in range(1,numResNet+1):
                f.write(str(fittingNetSizes[i+1])+"\n")
                label_resNet = catNameFittingRes(fittingNetIdx,resNetIdx)
                dump(raw[label_resNet][0],f)

        """ 

        """
            The format below fits Dr.Wang's Fortran routine
        """

        for keys in list(raw.keys()):
            tmp = keys.split('.')
            if module_sign:
                if tmp[1] == "fitting_net" and tmp[2] == '0' and tmp[3] == 'resnet_dt':
                    numResNet +=1
            else:
                if tmp[0] == "fitting_net" and tmp[1] == '0' and tmp[2] == 'resnet_dt':
                    numResNet +=1 

        print ("number of resnet: " + str(numResNet))

        filename  = os.path.join(out_path, "fittingNet.resnet")


        f= open(filename, "w")
        
        # itype: number of fitting network 
        f.write(str(nFittingNet)+'\n') 

        #nlayer: 
        f.write(str(nLayerFittingNet) + '\n')

        #dim of each layer 
        f.write(str(len(raw[catNameFittingW(0,0,has_module)]))+' ')

        for i in fittingNetSizes:
            f.write(str(i)+' ')	
        f.write("\n")

        for i in range(0,len(fittingNetSizes)+1):
            if (i > 1) and (i < len(fittingNetSizes)):
                f.write("1 ")
            else:
                f.write("0 ")

        f.write("\n")


        #f.write(str(numResNet)+"\n")

        for fittingNetIdx in range(nFittingNet):
            for resNetIdx in range(1,numResNet+1):
                f.write(str(fittingNetSizes[resNetIdx])+"\n")
                label_resNet = catNameFittingRes(fittingNetIdx,resNetIdx,has_module)   
                dump(raw[label_resNet][0],f)

        f.close()

    print("******** converting resnet ends  *********\n")


    """
        generating the deepMD.in 
        
    """

    print("******** generating gen_dp.in  *********")

    orderedAtomList = getOrderedAtom(atom_config_path)

    davg = np.load(davg_npy_path)
    dstd = np.load(dstd_npy_path)

    davg_size = len(davg)
    dstd_size = len(dstd)

    assert(davg_size == dstd_size)
    assert(davg_size == len(orderedAtomList))

    f_out = open(os.path.join(out_path, "gen_dp.in"),"w")

    # in default_para.py, Rc_M = 6.0 Rc_min = 5.8. This is also used for feature generations 

    f_out.write(str(config_yaml["atomType"][0]["Rc"]) + ' ') 
    f_out.write(str(config_yaml["maxNeighborNum"])+"\n")
    f_out.write(str(config_yaml["M2"])+"\n")
    f_out.write(str(dstd_size)+"\n")

    for i,atom in enumerate(orderedAtomList):
        f_out.write(atom+"\n")
        f_out.write(str(config_yaml["atomType"][0]["Rc"])+' '+str(config_yaml["atomType"][0]["Rm"])+'\n')

        # davg 
        # dstd 

        for idx in range(4):
            f_out.write(str(davg[i][idx])+" ")
        
        f_out.write("\n")

        for idx in range(4):
            f_out.write(str(dstd[i][idx])+" ")
        f_out.write("\n")

    f_out.close() 

    print("******** gen_dp.in generation done *********")

if __name__ == "__main__":
    # model_dir = "/home/wuxingxing/codespace/MLFF_wu_dev/mlff_wu_work_dir/dpnn_work_dir/ch4_system_test/init/model_dir/"
    # reload, model_pt_path, p_path = get_recent_model(model_dir)
    # out_path = os.path.join(model_dir, "read_torch_dp")
    out_path = "/share/home/wuxingxing/datas/system_config/c-LiSi_20230210/train/main_md"
    model_pt_path = "/share/home/wuxingxing/datas/system_config/c-LiSi_20230210/train/checkpoint.pth.tar"

    davg_npy_path = "/share/home/wuxingxing/datas/system_config/c-LiSi_20230210/train/train/davg.npy"
    dstd_npy_path = "/share/home/wuxingxing/datas/system_config/c-LiSi_20230210/train/train/dstd.npy"
    kfdp=True
    atom_config_path = "/share/home/wuxingxing/datas/system_config/c-LiSi_20230210/train/main_md/atom.config"
    config_yaml_path = "/share/home/wuxingxing/datas/system_config/c-LiSi_20230210/train/config.yaml"
    with open(config_yaml_path, "r") as yamlfile:
            config_yaml = yaml.load(yamlfile, Loader=yaml.FullLoader)
    read_torch_dp(config_yaml, model_pt_path, atom_config_path, out_path, davg_npy_path, dstd_npy_path)